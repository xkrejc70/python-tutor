scrabble:
  - question: 'For optimal efficiency, which code line should replace 1st blank line?'
    options:
      - 'set(''.join(perm) for word in words for perm in perms if word == perm)'
      - 'set(words).intersection(perms)'
      - 'set({item:None for item in perms if item in words}.keys())'
      - 'set(filter(lambda x: x in perms, words))'
    correctOption: 1
    explanations: 
      - 'Code uses nested loops to find words that are equal to permutations, resulting in a time complexity of O(n * m). A more efficient solution exists with a time complexity of O(n + m).'
      - 'Set intersection operation (&) is the most Pythonic and efficient way to find the common elements between two sets in this context.'
      - 'The provided solution inefficiently uses dictionary comprehension and membership tests for each permutation, resulting in a time complexity of O(n^2)'
      - 'This solution uses the filter function with a lambda function. It is less readable than set operations and less efficient for this specific problem.'
  - question: 'For optimal efficiency in sorting valid words by their total point value, which code line should replace 2nd blank line?'
    options:
      - 'max(list)'
      - 'dict.fromkeys()'
      - 'list.sort()'
      - 'sorted(list)'
    correctOption: 3
    explanations:
      - "`max` returns the maximum element, but it doesn't handle sorting of the entire list, making it less suitable for this specific problem."
      - "`dict.fromkeys` is also not recommended for sorting, as it focuses on uniqueness and lacks the specific functionality needed for efficient Scrabble word sorting."
      - "Using the `sort` method directly on the list is less efficient compared to the built-in function."
      - 'Built-in function `sorted` should run measurably faster as it is written in C.'
proj8:
  - question: 'What data structure should be used to store unique categories efficiently?'
    options:
      - 'List'
      - 'Dictionary'
      - 'Set'
      - 'Tuple'
    correctOption: 2
    explanations: 
      - 'List is inefficient for storing unique items. It does not offer optimized membership checks.'
      - 'Dictionary is not ideal for storing unique items. It introduces unnecessary complexity and overhead.'
      - 'Sets are ideal for storing unique items and offer efficient membership checks, making them suitable for identifying unique spam categories without redundant storage or slow lookup time.'
      - 'Tuple is not designed for storing unique items. It lacks efficient membership checks.'
  - question: 'How can we ensure memory efficiency when categorizing spam in a potentially infinite email queue?'
    options:
      - 'By using a dictionary to map email addresses to their spam categories'
      - 'By categorizing emails on-the-fly and storing only unique spam categories in a set'
      - 'By storing each email address in a list and filtering duplicates later'
      - 'By creating a tuple for each email containing its address and spam category'
    correctOption: 1
    explanations:
      - ''
      - 'Processing emails as they arrive and storing only unique spam categories in a set ensures memory efficiency and scalability, as it avoids storing redundant information and handles the potentially infinite email queue effectively.'
      - ''
      - ''
  - question: 'To optimize the mechanism for storing unique spam categories, what would be a suitable approach?'
    options:
      - 'Using hash function to convert the long string into a compact hashed value'
      - 'Applying a complex encryption algorithm to the category name and description'
      - 'Storing categories in a plain list and iterating through it for each new email to find duplicates'
      - 'Concatenating the category name with its description as a single string'
    correctOption: 0
    explanations:
      - 'Hashing allows for constant-time average-case lookup in a set. Storing hashed values can improve memory efficiency. Hashes are typically smaller in size compared to the objects they represent.'
      - 'Encryption is designed for security. It adds unnecessary computational overhead.'
      - 'This approach is inefficient because it requires checking every existing category in a list for each new email, resulting in a time-consuming linear search operation.'
      - 'This approach might be inefficient and would not provide a fixed-size compact representation. It could lead to unnecessary memory usage and slower comparisons.'
  - question: 'What is a suitable approach to handle potential errors when processing emails?'
    options:
      - 'Ignoring errors and continuing with the next email in the queue.'
      - 'Halting the entire process if an error is encountered to avoid further complications.'
      - 'Adding a try block to catch and handle exceptions that may occur during email processing.'
      - 'Logging errors to a file without interrupting the category generation process.'
    correctOption: 2
    explanations:
      - 'Ignoring errors may lead to incomplete category generation and overlook potential issues in the email processing logic.'
      - 'Halting the process entirely upon encountering an error is not ideal for scalability and continuous category generation.'
      - 'Adding a try block allows for catching and handling exceptions that may occur during email processing, promoting robust error handling without halting the entire generator.'
      - 'Logging errors can be beneficial for debugging but should be accompanied by appropriate error handling to ensure the continuous operation of the category generator.'
  - question: 'How to efficiently return values for unique spam categories?'
    options:
      - 'By storing all categories in a list and returning the entire list'
      - 'By using a dictionary to map categories to their respective counts and returning the dictionary'
      - 'By creating a tuple for each category containing its name and description and returning them as a list'
      - 'By categorizing categories on-the-fly and returning them one at a time using the yield keyword'
    correctOption: 3
    explanations:
      -  'Inefficient; storing all categories upfront may lead to performance issues, especially with a large number of categories.'
      -  'Unnecessarily complex; using counts in a dictionary introduces unnecessary overhead and may result in a larger data structure.'
      -  'Adds unnecessary complexity; creating additional tuples without clear benefits complicates the structure without improving the goal of returning unique categories.'
      - 'The yield keyword is more memory-efficient, processing one category at a time and minimizing storage needs by avoiding simultaneous memory storage of all categories.'
template:
  - question: ''
    options:
      - ''
      - ''
      - ''
      - ''
    correctOption: 3
    explanations: 
      - ''
      - ''
      - ''
      - ''

